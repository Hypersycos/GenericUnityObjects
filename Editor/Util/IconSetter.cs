namespace GenericUnityObjects.Editor.Util
{
    using System;
    using System.Collections.Generic;
    using GenericUnityObjects.Util;
    using SolidUtilities.Helpers;
    using SolidUtilities.UnityEditorInternals;
    using UnityEditor;
    using UnityEditor.Callbacks;
    using UnityEngine;

    /// <summary>
    /// By default, an icon of a MonoScript asset generated from an assembly is different from an icon of a C# script.
    /// This makes generic components look different. This class sets generic MonoBehaviour icons to be the same as the usual ones.
    /// </summary>
    internal class IconSetter : EditorOnlySingletonSO<IconSetter>, ICanBeInitialized, ISerializationCallbackReceiver
    {
        [SerializeField] private Texture2D[] _keys;
        [SerializeField] private Collection<string>[] _values;

        private FastIterationDictionary<Texture2D, List<string>> _dict;

        public static void AddAssemblyForIconChange(string genericScriptGUID, string assemblyGUID, bool isScriptableObject)
        {
            if (string.IsNullOrEmpty(genericScriptGUID))
                return;

            if (TryGetCustomIcon(genericScriptGUID, out Texture2D texture, isScriptableObject))
                Instance.AddAssembly(assemblyGUID, texture);
        }

        private static bool TryGetCustomIcon(string genericTypeGUID, out Texture2D customIcon, bool isScriptableObject)
        {
            customIcon = null;

            string assetPath = AssetDatabase.GUIDToAssetPath(genericTypeGUID);

            if (string.IsNullOrEmpty(assetPath))
                return false;

            var monoScript = AssetDatabase.LoadAssetAtPath<MonoScript>(assetPath);

            if (monoScript is null)
                return false;

            customIcon = AssetPreview.GetMiniThumbnail(monoScript);

            // If generated type inherits from MonoBehaviour, a default script icon must be set, but for scriptable
            // objects, it is not the case.
            return ! (isScriptableObject && customIcon.name.Contains("cs Script Icon"));
        }

        private void AddAssembly(string guid, Texture2D texture)
        {
            if ( ! _dict.TryGetValue(texture, out List<string> guids))
            {
                guids = new List<string>();
                _dict.Add(texture, guids);
            }

            guids.Add(guid);

            EditorUtility.SetDirty(Instance);
        }

        // 1. GenericTypesAnalyzer finds a new generic MonoBehaviour and generates a DLL.
        // 2. Scripts are recompiled because of the DLL addition.
        // 3. This event is fired before GenericTypesAnalyzer is called again, and sets the custom icon.
        // Icons cannot be set immediately after generating a DLL because MonoScript is not generated by Unity yet.
        [DidReloadScripts((int)DidReloadScriptsOrder.BeforeAssemblyGeneration)]
        private static void SetIcons()
        {
            if (Instance._dict.Count == 0)
                return;

            using (new DisabledAssetDatabase(true))
            {
                foreach (var kvp in Instance._dict)
                {
                    foreach (string guid in kvp.Value)
                    {
                        string path = AssetDatabase.GUIDToAssetPath(guid);
                        var script = AssetDatabase.LoadAssetAtPath<MonoScript>(path);

                        // Something unexpected happened. The newly generated assembly was removed while the scripts were reloading.
                        // It shouldn't stop us from setting other assemblies' icons and clearing them up in the end.
                        if (script == null)
                            continue;

                        EditorGUIUtilityProxy.SetIconForObject(script, kvp.Key);
                        MonoImporterProxy.CopyMonoScriptIconToImporters(script);
                    }
                }
            }

            ClearIconChangeGUIDs();

            // If some icons are changed and an asset needs to be created, its creation process is triggered but does
            // not finish because of the domain reload associated with the icons change. That's why the event must be
            // skipped so that the asset is created properly after the domain reload.
            PersistentStorage.SkipAfterAssemblyGenerationEvent();
        }

        private static void ClearIconChangeGUIDs()
        {
            Instance._dict.Clear();
            EditorUtility.SetDirty(Instance);
        }

        public void Initialize()
        {
            if (_keys != null)
                throw new InvalidOperationException("The asset is already initialized.");

            _dict = new FastIterationDictionary<Texture2D, List<string>>();
        }

        public void OnBeforeSerialize()
        {
            if (_dict == null)
                return;

            int dictLength = _dict.Count;

            _keys = new Texture2D[dictLength];
            _values = new Collection<string>[dictLength];

            int index = 0;

            foreach (var kvp in _dict)
            {
                _keys[index] = kvp.Key;
                _values[index] = kvp.Value;
                index++;
            }
        }

        public void OnAfterDeserialize()
        {
            if (_keys == null)
                return;

            int keysLength = _keys.Length;
            _dict = new FastIterationDictionary<Texture2D, List<string>>(keysLength);

            for (int i = 0; i < keysLength; i++)
            {
                var key = _keys[i];
                var value = _values[i];

                if (key == null)
                    continue;

                _dict.Add(key, value);
            }
        }
    }
}